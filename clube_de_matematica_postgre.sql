BEGIN;

-- Revogar o privilégio "PUBLIC" padrão do esquema "public" para o comando "CREATE".
-- Isso aumentará a segurança das funções definidas com o nível de segurança "SECURITY DEFINER".
REVOKE CREATE ON SCHEMA public FROM PUBLIC;

CREATE TABLE "questoes" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  "enunciado" TEXT[] NOT NULL,
  "gabarito" INT4 NOT NULL,
  "imagens_enunciado" JSONB[],
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC'))
);

CREATE TABLE "assunto_x_assunto_pai" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  "assunto" TEXT NOT NULL,
  "id_assunto_pai" INT4 DEFAULT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  UNIQUE ("id", "assunto"),
  UNIQUE ("assunto", "id_assunto_pai")
);

CREATE TABLE "assuntos" (
  "id" INT4 UNIQUE NOT NULL,
  "assunto" TEXT NOT NULL,
  "hierarquia" INT4[] DEFAULT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  UNIQUE ("assunto", "hierarquia")
);

CREATE TABLE "questao_x_assunto" (
  "id_questao" INT4 NOT NULL,
  "id_assunto" INT4 NOT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  PRIMARY KEY ("id_questao", "id_assunto")
);

CREATE TABLE "tipos_alternativa" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  "tipo" VARCHAR UNIQUE NOT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC'))
);

CREATE TABLE "alternativas" (
  "id_questao" INT4 NOT NULL,
  "sequencial" INT4 NOT NULL,
  "id_tipo" INT4 NOT NULL,
  "conteudo" TEXT NOT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  PRIMARY KEY ("id_questao", "sequencial")
);

CREATE TABLE "questoes_caderno" (
  "id" VARCHAR PRIMARY KEY NOT NULL,
  "ano" INT4 NOT NULL,
  "nivel" INT4 NOT NULL,
  "indice" INT4 NOT NULL,
  "id_questao" INT4 NOT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC'))
);

CREATE TABLE "usuarios" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  --"uuid" UUID REFERENCES auth.users("id") UNIQUE NOT NULL,
  "email" VARCHAR UNIQUE NOT NULL,
  "nome" VARCHAR,
  "foto" TEXT,
  "soft_delete" BOOL NOT NULL DEFAULT FALSE,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC'))
);

CREATE TABLE "permissao_acesso_banco_questoes" (
  "id_usuario" INT4 PRIMARY KEY NOT NULL,
  "inserir" BOOL NOT NULL DEFAULT FALSE,
  "editar" BOOL NOT NULL DEFAULT FALSE,
  "excluir" BOOL NOT NULL DEFAULT FALSE,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC'))
);

CREATE TABLE "log_banco_questoes" (
  "pk" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "id_usuario" INT4,
  "nome" VARCHAR,
  "email" VARCHAR,
  "tabela" VARCHAR NOT NULL,
  "pk_registro" JSONB NOT NULL,
  "operacao" VARCHAR NOT NULL,
  "data" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (now() AT TIME ZONE 'UTC')
);

CREATE TABLE "clubes" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  "nome" VARCHAR UNIQUE NOT NULL,
  "descricao" VARCHAR,
  "data_criacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "privado" BOOL NOT NULL DEFAULT FALSE, 
  "codigo" VARCHAR UNIQUE NOT NULL,
  "capa" VARCHAR,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "excluir" BOOL NOT NULL DEFAULT FALSE
);

CREATE TABLE "tipos_permissao" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  "permissao" VARCHAR UNIQUE NOT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC'))
);

CREATE TABLE "clube_x_usuario" (
  "id_clube" INT4 NOT NULL,
  "id_usuario" INT4 NOT NULL,
  "id_permissao" INT4 NOT NULL,
  "data_admissao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "excluir" BOOL NOT NULL DEFAULT FALSE,
  PRIMARY KEY ("id_clube", "id_usuario")
);

CREATE TABLE "atividades" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  "id_clube" INT4 NOT NULL,
  "titulo" TEXT NOT NULL,
  "descricao" TEXT,
  "data_criacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "id_autor" INT4 NOT NULL,
  "data_liberacao" TIMESTAMP WITHOUT TIME ZONE,
  "data_encerramento" TIMESTAMP WITHOUT TIME ZONE,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "excluir" BOOL NOT NULL DEFAULT FALSE,
  UNIQUE ("id_clube", "titulo")
);

CREATE TABLE "questao_x_atividade" (
  "id" INT4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY NOT NULL,
  "id_questao_caderno" VARCHAR NOT NULL,
  "id_atividade" INT4 NOT NULL,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "excluir" BOOL NOT NULL DEFAULT FALSE,
  UNIQUE ("id_atividade", "id_questao_caderno")
);

CREATE TABLE "resposta_x_questao_x_atividade" (
  "id_questao_x_atividade" INT4 NOT NULL,
  "id_usuario" INT4 NOT NULL,
  "resposta" INT4,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "excluir" BOOL NOT NULL DEFAULT FALSE,
  PRIMARY KEY ("id_questao_x_atividade", "id_usuario")
);

CREATE TABLE "resposta_x_questao" (
  "id_questao" INT4 NOT NULL,
  "id_usuario" INT4 NOT NULL,
  "resposta" INT4,
  "data_modificacao" TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (date_trunc('milliseconds', now() AT TIME ZONE 'UTC')),
  "excluir" BOOL NOT NULL DEFAULT FALSE,
  PRIMARY KEY ("id_questao", "id_usuario")
);

ALTER TABLE "assunto_x_assunto_pai" ADD FOREIGN KEY ("id_assunto_pai") REFERENCES "assunto_x_assunto_pai" ("id") ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE "assuntos" ADD FOREIGN KEY ("id", "assunto") REFERENCES "assunto_x_assunto_pai" ("id", "assunto") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "questao_x_assunto" ADD FOREIGN KEY ("id_questao") REFERENCES "questoes" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "questao_x_assunto" ADD FOREIGN KEY ("id_assunto") REFERENCES "assunto_x_assunto_pai" ("id") ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE "alternativas" ADD FOREIGN KEY ("id_questao") REFERENCES "questoes" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "alternativas" ADD FOREIGN KEY ("id_tipo") REFERENCES "tipos_alternativa" ("id") ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE "questoes_caderno" ADD FOREIGN KEY ("id_questao") REFERENCES "questoes" ("id") ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE "permissao_acesso_banco_questoes" ADD FOREIGN KEY ("id_usuario") REFERENCES "usuarios" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "log_banco_questoes" ADD FOREIGN KEY ("id_usuario") REFERENCES "usuarios" ("id") ON DELETE NO ACTION ON UPDATE CASCADE;

ALTER TABLE "log_banco_questoes" ADD FOREIGN KEY ("email") REFERENCES "usuarios" ("email") ON DELETE NO ACTION ON UPDATE CASCADE;

ALTER TABLE "clube_x_usuario" ADD FOREIGN KEY ("id_clube") REFERENCES "clubes" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "clube_x_usuario" ADD FOREIGN KEY ("id_usuario") REFERENCES "usuarios" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "clube_x_usuario" ADD FOREIGN KEY ("id_permissao") REFERENCES "tipos_permissao" ("id") ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE "atividades" ADD FOREIGN KEY ("id_clube") REFERENCES "clubes" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- A intenção é que um usuário nunca seja excluído. Em vez disso o campo "soft_delete" deve ser marcado como verdadeiro. A cláusula "ON DELETE RESTRICT" é apenas uma garantia extra.
ALTER TABLE "atividades" ADD FOREIGN KEY ("id_autor") REFERENCES "usuarios" ("id") ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE "questao_x_atividade" ADD FOREIGN KEY ("id_questao_caderno") REFERENCES "questoes_caderno" ("id") ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE "questao_x_atividade" ADD FOREIGN KEY ("id_atividade") REFERENCES "atividades" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "resposta_x_questao_x_atividade" ADD FOREIGN KEY ("id_questao_x_atividade") REFERENCES "questao_x_atividade" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "resposta_x_questao_x_atividade" ADD FOREIGN KEY ("id_usuario") REFERENCES "usuarios" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "resposta_x_questao" ADD FOREIGN KEY ("id_questao") REFERENCES "questoes" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "resposta_x_questao" ADD FOREIGN KEY ("id_usuario") REFERENCES "usuarios" ("id") ON DELETE CASCADE ON UPDATE CASCADE;

CREATE INDEX ON "assunto_x_assunto_pai" ("assunto");

CREATE INDEX ON "assuntos" ("assunto");

CREATE INDEX ON "assuntos" ("hierarquia");

CREATE INDEX ON "questao_x_assunto" ("id_questao");

CREATE INDEX ON "questao_x_assunto" ("id_assunto");

CREATE INDEX ON "alternativas" ("id_questao");

CREATE INDEX ON "questoes_caderno" ("ano");

CREATE INDEX ON "questoes_caderno" ("nivel");

CREATE INDEX ON "questoes_caderno" ("id_questao");

CREATE INDEX ON "questoes_caderno" ("ano", "nivel");

CREATE INDEX ON "clube_x_usuario" ("id_clube");

CREATE INDEX ON "clube_x_usuario" ("id_usuario");

CREATE INDEX ON "atividades" ("id_clube");

CREATE INDEX ON "atividades" ("id_clube", "id_autor");

CREATE INDEX ON "questao_x_atividade" ("id_atividade");

CREATE INDEX ON "resposta_x_questao_x_atividade" ("id_questao_x_atividade");

CREATE INDEX ON "resposta_x_questao" ("id_questao");

COMMENT ON COLUMN "questoes"."enunciado" IS 'Lista (array) com as partes do enunciado da questão. A fragmentação é para indicar pontos de inserção de imágens.';

COMMENT ON COLUMN "questoes"."gabarito" IS 'Identificador ordinal da alternativa correta da questão.';

COMMENT ON COLUMN "questoes"."imagens_enunciado" IS 'Lista (array) com as strings base64 das imagens usadas no enunciado da questão.';

COMMENT ON TABLE "assunto_x_assunto_pai" IS 'Contém os assuntos associados a cada questão, bem como o respectivo assunto imediatamente superior na hierarquia de assuntos.';

COMMENT ON COLUMN "assunto_x_assunto_pai"."assunto" IS 'Assunto mais específico da questão.';

COMMENT ON COLUMN "assunto_x_assunto_pai"."id_assunto_pai" IS 'Tópico imediatamente superior ao assunto. Será NULL se o assunto for uma unidade.';

COMMENT ON TABLE "assuntos" IS 'Contém os assuntos associados a cada questão, bem como o respectivo assunto imediatamente superior na hierarquia de assuntos. Essa tabela será atualizada sempre que uma alteração ocorrer em "assunto_x_assunto_pai". Essa tabela é uma cópia da visualização "view_assuntos". Ela existe para minimizar o uso da consulta recursiva usada na visualização.';

COMMENT ON COLUMN "assuntos"."assunto" IS 'Assunto mais específico da questão.';

COMMENT ON COLUMN "assuntos"."hierarquia" IS 'Uma lista (array) com a hierarquia do assunto, iniciando pela unidade. A lista não contém o assunto. Será uma lista vazia se o assunto for uma unidade.';

COMMENT ON TABLE "questao_x_assunto" IS 'Faz o relacionamento muitos para muitos entre as tabelas "questoes" e "assuntos".';

COMMENT ON TABLE "alternativas" IS 'Contém todas as alternativas de resposta usadas nas questões.';

COMMENT ON COLUMN "alternativas"."id_questao" IS 'ID da questão ao qual a alternativa pertence.';

COMMENT ON COLUMN "alternativas"."sequencial" IS 'Identificador ordinal da alternativa. O primeiro valor é 0 (zero).';

COMMENT ON COLUMN "alternativas"."conteudo" IS 'Se id_tipo = 0, contém o texto da alternativa (pode conter um código LaTex. Se id_tipo = 1, contém a string base64 da imagem.';

COMMENT ON TABLE "tipos_alternativa" IS 'Contém os tipos de alternativa disponíveis.';

COMMENT ON COLUMN "tipos_alternativa"."id" IS 'Identificador do tipo da alternativa. 0 (zero) para "texto" e 1 (um) para "imagem".';

COMMENT ON COLUMN "tipos_alternativa"."tipo" IS '"imagem" ou "texto".';

COMMENT ON TABLE "questoes_caderno" IS 'Relaciona as questões por caderno. Se uma questão foi usada em mais de um caderno, nesta tabela ela possuirá um registro para cada um desses cadernos.';

COMMENT ON COLUMN "questoes_caderno"."id" IS 'ID do item (questão). Os valores deste campo estão no formato "2019PF1N1Q01", onde: "2019" é o ano de aplicação da prova; "PF1" indica que a prova é da primeira fase; "N1" indica que a prova é do nível 1; "Q01" indica que trata-se do primeiro item do caderno.';

COMMENT ON COLUMN "questoes_caderno"."ano" IS 'Ano de aplicação da questão.';

COMMENT ON COLUMN "questoes_caderno"."nivel" IS 'O nível da prova da OBMEP.';

COMMENT ON COLUMN "questoes_caderno"."indice" IS 'O número da questão no caderno de prova.';

COMMENT ON COLUMN "usuarios"."foto" IS 'String base64 da foto de perfil do usuário.';

COMMENT ON COLUMN "usuarios"."soft_delete" IS 'Se verdadeiro, o usuário foi marcado como excluído.';

COMMENT ON TABLE "clubes" IS 'Contém as informações dos clubes criados.';

COMMENT ON COLUMN "clubes"."nome" IS 'Nome do clube.';

COMMENT ON COLUMN "clubes"."descricao" IS 'Uma pequena descrição sobre o clube.';

COMMENT ON COLUMN "clubes"."data_criacao" IS 'Data/hora (no fuso horário UTC) da criação do clube.';

COMMENT ON COLUMN "clubes"."privado" IS 'Se "FALSE", qualquer usuário com o código de acesso pode participar do grupo. Senão, o proprietario ou um administrador deve autorizar o ingresso.';

COMMENT ON COLUMN "clubes"."codigo" IS 'O ID base62 de acesso ao clube.';

COMMENT ON COLUMN "clubes"."capa" IS 'A imágem ou a cor de capa.';

COMMENT ON TABLE "clube_x_usuario" IS 'Faz o relacionamento muitos para muitos entre as tabelas "clubes" e "usuarios".';

COMMENT ON COLUMN "clube_x_usuario"."id_permissao" IS '0 (zero) para "proprietário", 1 para "administrador" e 2 para "membro".';

COMMENT ON COLUMN "clube_x_usuario"."data_admissao" IS 'Data/hora (no fuso horário UTC) do ingresso do usuário ao clube.';

COMMENT ON TABLE "tipos_permissao" IS 'Contém os tipos de permissão disponíveis para os usuários.';

COMMENT ON COLUMN "tipos_permissao"."id" IS '0 (zero) para "proprietario", 1 para "administrador" e 2 para "membro".';

COMMENT ON COLUMN "tipos_permissao"."permissao" IS '"proprietário", "administrador" ou "membro".';

COMMENT ON TABLE "permissao_acesso_banco_questoes" IS 'Contém as permissões de acesso para os usuários que colaboram com a alimentação do banco de questões. A permissão de leitura não consta na tabela pois está disponível para qualquer usuário.';

COMMENT ON COLUMN "permissao_acesso_banco_questoes"."inserir" IS 'Indica se o usuário tem permissão para inserír questões. O padrão é FALSE.';

COMMENT ON COLUMN "permissao_acesso_banco_questoes"."editar" IS 'Indica se o usuário tem permissão para editar questões. O padrão é FALSE.';

COMMENT ON COLUMN "permissao_acesso_banco_questoes"."excluir" IS 'Indica se o usuário tem permissão para excluir questões. O padrão é FALSE.';

COMMENT ON TABLE "log_banco_questoes" IS 'Contém contém os registros de alterações nos dados do banco de questões.';

COMMENT ON COLUMN "log_banco_questoes"."id_usuario" IS 'Contém o ID do usuário que fez a operação no banco de questões.';

COMMENT ON COLUMN "log_banco_questoes"."nome" IS 'Contém o nome do usuário (interno do Postgres) que fez a operação no banco de questões.';

COMMENT ON COLUMN "log_banco_questoes"."email" IS 'Contém o email do usuário que fez a operação no banco de questões.';

COMMENT ON COLUMN "log_banco_questoes"."tabela" IS 'Contém o nome da tabela que foi afetada.';

COMMENT ON COLUMN "log_banco_questoes"."pk_registro" IS 'Contém um JSON com a(s) chave(s) primária(s) para o registro na tabela que foi afetada. A(s) chave(s) do JSON é(são) o(s) nome(s) da(s) coluna(s) que é(são) chave(s) primária(s) na tabela que foi afetada.';

COMMENT ON COLUMN "log_banco_questoes"."tabela" IS 'Contém o nome da operação (INSERT, UPDATE ou DELETE) executada no banco de questões.';

COMMENT ON COLUMN "log_banco_questoes"."data" IS 'Contém o carimbo de data e hora da tranzação que fez a alteração no banco de questões.';

COMMENT ON TABLE "atividades" IS 'Contém todas as atividades criadas nos clubes.';

COMMENT ON COLUMN "atividades"."id_clube" IS 'ID do clube ao qual a atividade pertence.';

COMMENT ON COLUMN "atividades"."data_criacao" IS 'Data/hora (no fuso horário UTC) da criação da atividade.';

COMMENT ON COLUMN "atividades"."id_autor" IS 'ID do usuário que criou a atividade.';

COMMENT ON COLUMN "atividades"."data_liberacao" IS 'Data/hora (no fuso horário UTC) da liberação da atividade para os usuários do clube. Será NULL se ainda não tiver sido liberada.';

COMMENT ON COLUMN "atividades"."data_encerramento" IS 'Data/hora (no fuso horário UTC) final para que a atividade seja concluída.';

COMMENT ON TABLE "questao_x_atividade" IS 'Faz o relacionamento muitos para muitos entre as tabelas "questoes" e "atividades".';

COMMENT ON TABLE "resposta_x_questao_x_atividade" IS 'Contém as respostas dos membros dos clubes às atividades.';

COMMENT ON COLUMN "resposta_x_questao_x_atividade"."resposta" IS 'O sequencial da alternativa escolhida.';

COMMENT ON TABLE "resposta_x_questao" IS 'Contém as respostas dos usuários não vinculadas a clubes.';

COMMENT ON COLUMN "resposta_x_questao"."resposta" IS 'O sequencial da alternativa escolhida.';

----------------------------------------------------------------------------------------------------------------------------

-- Tipos de alternativa pré-definidos.
INSERT INTO "tipos_alternativa" ("id", "tipo") OVERRIDING SYSTEM VALUE VALUES (0, 'texto'), (1, 'imagem');
SELECT setval('tipos_alternativa_id_seq', 1, true);

-- Tipos de permissão pré-definidos.
INSERT INTO "tipos_permissao" ("id", "permissao") OVERRIDING SYSTEM VALUE VALUES (0, 'proprietario'), (1, 'administrador'), (2, 'membro');
SELECT setval('tipos_permissao_id_seq', 2, true);

----------------------------------------------------------------------------------------------------------------------------
-- Políticas de acesso:
ALTER TABLE questoes ENABLE ROW LEVEL SECURITY;

                      CREATE POLICY "O usuário anônimo pode ler em questoes."
                        ON questoes FOR SELECT
                        USING (anonimo());
                      -- Substituir por:
                      CREATE POLICY "O usuário anônimo pode ler em questoes."
                        ON questoes FOR SELECT
                        TO anon
                        USING (TRUE);

                      CREATE POLICY "O usuário autenticado pode ler em questoes."
                        ON questoes FOR SELECT
                        USING (autenticado());
                      -- Substituir por:
                      CREATE POLICY "O usuário autenticado pode ler em questoes."
                        ON questoes FOR SELECT
                        TO authenticated
                        USING (TRUE);

CREATE POLICY "Usuários específicos podem inserir em questoes."
  ON questoes FOR INSERT
  WITH CHECK (get_permissao_inserir_questao());

---------------

ALTER TABLE assunto_x_assunto_pai ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário anônimo pode ler em assunto_x_assunto_pai."
  ON assunto_x_assunto_pai FOR SELECT
  USING (anonimo());

CREATE POLICY "O usuário autenticado pode ler em assunto_x_assunto_pai."
  ON assunto_x_assunto_pai FOR SELECT
  USING (autenticado());

CREATE POLICY "Usuários específicos podem inserir em assunto_x_assunto_pai."
  ON assunto_x_assunto_pai FOR INSERT
  WITH CHECK (get_permissao_inserir_questao());

---------------

ALTER TABLE assuntos ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário anônimo pode ler em assuntos."
  ON assuntos FOR SELECT
  USING (anonimo());

CREATE POLICY "O usuário autenticado pode ler em assuntos."
  ON assuntos FOR SELECT
  USING (autenticado());

CREATE POLICY "Usuários específicos podem inserir em assuntos."
  ON assuntos FOR INSERT
  WITH CHECK (get_permissao_inserir_questao());

---------------

ALTER TABLE questao_x_assunto ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário anônimo pode ler em questao_x_assunto."
  ON questao_x_assunto FOR SELECT
  USING (anonimo());

CREATE POLICY "O usuário autenticado pode ler em questao_x_assunto."
  ON questao_x_assunto FOR SELECT
  USING (autenticado());

CREATE POLICY "Usuários específicos podem inserir em questao_x_assunto."
  ON questao_x_assunto FOR INSERT
  WITH CHECK (get_permissao_inserir_questao());

---------------

ALTER TABLE alternativas ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário anônimo pode ler em alternativas."
  ON alternativas FOR SELECT
  USING (anonimo());

CREATE POLICY "O usuário autenticado pode ler em alternativas."
  ON alternativas FOR SELECT
  USING (autenticado());

CREATE POLICY "Usuários específicos podem inserir em alternativas."
  ON alternativas FOR INSERT
  WITH CHECK (get_permissao_inserir_questao());

---------------

ALTER TABLE tipos_alternativa ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário anônimo pode ler em tipos_alternativa."
  ON tipos_alternativa FOR SELECT
  USING (anonimo());

CREATE POLICY "O usuário autenticado pode ler em tipos_alternativa."
  ON tipos_alternativa FOR SELECT
  USING (autenticado());

---------------

ALTER TABLE questoes_caderno ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário anônimo pode ler em questoes_caderno."
  ON questoes_caderno FOR SELECT
  USING (anonimo());

CREATE POLICY "O usuário autenticado pode ler em questoes_caderno."
  ON questoes_caderno FOR SELECT
  USING (autenticado());

CREATE POLICY "Usuários específicos podem inserir em questoes_caderno."
  ON questoes_caderno FOR INSERT
  WITH CHECK (get_permissao_inserir_questao());

---------------

ALTER TABLE usuarios ENABLE ROW LEVEL SECURITY;

-- Retorna verdadeiro se os usuários correspondentes a "_id_requerido" e "_id_requerente" têm um clube em comum.
-- Se "_id_requerente" for omitido ou for NULL, o ID do usuário atual será usado.
-- Se "_incluir_excluidos" for TRUE, os registros marcados como excluídos também serão considerados.
CREATE OR REPLACE FUNCTION verificar_permissao_acessar_perfil_outro_usuario(
  _id_requerido INT4, 
  _id_requerente INT4 DEFAULT get_id_usuario(), 
  _incluir_excluidos BOOLEAN DEFAULT FALSE
) RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1 FROM clube_x_usuario AS x WHERE 
        COALESCE(x.id_usuario = _id_requerente, FALSE)
        AND (NOT x.excluir OR COALESCE(_incluir_excluidos, FALSE))
        AND EXISTS (
          SELECT 1 FROM clube_x_usuario AS y WHERE 
              COALESCE(y.id_usuario = _id_requerido, FALSE)
              AND (NOT y.excluir OR COALESCE(_incluir_excluidos, FALSE))
              AND y.id_clube = x.id_clube
        )
  );
$$ LANGUAGE SQL 
-- A função ignora o RLS, pois será executada com o nível de permissão do usuário a criou.
SECURITY DEFINER
-- Forçar o esquema temporário a ser pesquisado por último e priorizar os objetos do esquesma nativo.
SET search_path = pg_catalog, public, pg_temp;

CREATE POLICY "O usuário pode ler seus dados de perfil."
  ON usuarios FOR SELECT
  USING (auth.email() = email);

CREATE POLICY "O usuário pode ler dados de outros que participam do mesmo clube."
  ON usuarios FOR SELECT
  USING (verificar_permissao_acessar_perfil_outro_usuario("id"));

CREATE POLICY "O usuário pode inserir seus dados de perfil."
  ON usuarios FOR INSERT
  WITH CHECK (auth.email() = email);

CREATE POLICY "O usuário pode atualizar seus dados de perfil."
  ON usuarios FOR UPDATE
  USING (auth.email() = email)
  WITH CHECK (auth.email() = email);

---------------

ALTER TABLE permissao_acesso_banco_questoes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário autenticado pode ler em permissao_acesso_banco_questoes."
  ON permissao_acesso_banco_questoes FOR SELECT
  TO authenticated 
  USING (TRUE);

---------------

ALTER TABLE log_banco_questoes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Quem altera o banco de questões pode ler em log_banco_questoes."
  ON log_banco_questoes FOR SELECT
  TO authenticated 
  USING (get_permissao_inserir_questao() OR get_permissao_editar_questao() OR get_permissao_excluir_questao());

CREATE POLICY "Quem altera o banco de questões insere em log_banco_questoes."
  ON log_banco_questoes FOR INSERT
  TO authenticated 
  WITH CHECK (get_permissao_inserir_questao() OR get_permissao_editar_questao() OR get_permissao_excluir_questao());

-- Ainda não foi testada
CREATE POLICY "Quem quem criou o registro pode editá-lo em log_banco_questoes."
  ON log_banco_questoes FOR UPDATE
  TO authenticated 
  USING (log_banco_questoes.id_usuario = get_id_usuario()) 
  WITH CHECK (log_banco_questoes.id_usuario = get_id_usuario());

---------------

ALTER TABLE clubes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Apenas o usuário autenticado pode ler em clubes."
  ON clubes AS RESTRICTIVE FOR SELECT
  USING (autenticado());

CREATE POLICY "Os participantes podem ler dados do clube."
  ON clubes FOR SELECT
  USING (
    -- Verificar apenas participantes não excluídos.
    get_permissao_clube("id") IS NOT NULL
    -- Verificar também participantes excluídos
    OR (get_permissao_clube("id", TRUE) IS NOT NULL AND excluir)
  );

-- Permissão para participar de clube pelo código de acesso.
CREATE POLICY "O usuário com o código de acesso pode ler em clubes."
  ON clubes FOR SELECT
  USING (
    COALESCE(
      codigo = current_setting('app.clube.codigo', TRUE)::VARCHAR, 
      FALSE
    )
    AND NOT excluir
  );

CREATE POLICY "O usuário autenticado pode escrever em clubes."
  ON clubes FOR INSERT
  WITH CHECK (autenticado());

CREATE POLICY "Apenas usuários autenticados podem atualizar em clubes."
  ON clubes AS RESTRICTIVE FOR UPDATE
  USING (autenticado()); 

CREATE POLICY "O proprietário do clube pode atualizar em clubes."
  ON clubes FOR UPDATE
  USING (COALESCE(get_permissao_clube("id") = 0, FALSE));

--------------- 

ALTER TABLE tipos_permissao ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário autenticado pode ler os tipos de permissão de clube."
  ON tipos_permissao FOR SELECT
  USING (autenticado());

---------------

 ALTER TABLE clube_x_usuario ENABLE ROW LEVEL SECURITY;

-- Retorna o ID da permissão do usuário correspondente a "_id_usuario" para o clube correspondente a "_id_clube".
-- Se "_id_usuario" for omitido ou for NULL, o ID do usuário atual será usado.
-- Retorna NULL se nenhuma permissão estiver definida para o usuário.
CREATE OR REPLACE FUNCTION get_permissao_clube(
  _id_clube INT4, 
  _incluir_excluidos BOOLEAN DEFAULT FALSE, 
  _id_usuario INT4 DEFAULT NULL
) RETURNS INT4 AS $$
  DECLARE _id_permissao INT4;
  BEGIN
    IF (_id_clube IS NULL) THEN 
      RETURN NULL;
    END IF;
    SELECT id_permissao INTO _id_permissao FROM clube_x_usuario 
        WHERE id_clube = _id_clube 
            AND id_usuario = COALESCE(_id_usuario, get_id_usuario()) 
            AND (COALESCE(_incluir_excluidos, FALSE) OR NOT excluir)
        LIMIT 1;
    RETURN _id_permissao;
  END;
$$ LANGUAGE PLPGSQL 
-- A função ignora o RLS, pois será executada com o nível de permissão do usuário a criou.
SECURITY DEFINER
-- Forçar o esquema temporário a ser pesquisado por último e priorizar os objetos do esquesma nativo.
SET search_path = pg_catalog, public, pg_temp;

CREATE POLICY "Apenas usuários autenticados podem ler em clube_x_usuario."
  ON clube_x_usuario AS RESTRICTIVE FOR SELECT
  USING (autenticado()); 
 
CREATE POLICY "O usuário vinculado ao registro pode ler em clube_x_usuario."
  ON clube_x_usuario AS PERMISSIVE FOR SELECT
  USING (id_usuario = get_id_usuario());

CREATE POLICY "Os participantes podem ler registros do clube em clube_x_usuario."
  ON clube_x_usuario AS PERMISSIVE FOR SELECT
  USING (
    -- Verificar apenas participantes não excluídos.
    get_permissao_clube(id_clube) IS NOT NULL
    -- Verificar também participantes excluídos
    OR (get_permissao_clube(id_clube, TRUE) IS NOT NULL AND excluir)
  );

CREATE POLICY "Apenas usuários autenticados podem escrever em clube_x_usuario."
  ON clube_x_usuario AS RESTRICTIVE FOR INSERT
  WITH CHECK (autenticado());

-- Permissão para participar de clube pelo código de acesso.
CREATE POLICY "O usuário com o código de acesso do clube pode escrever em clube_x_usuario."
  ON clube_x_usuario FOR INSERT
  WITH CHECK (
    id_usuario = get_id_usuario()
    AND id_permissao = 2
    AND EXISTS (
      SELECT 1 FROM clubes AS "temp"
      WHERE "temp"."id" = clube_x_usuario.id_clube 
          AND COALESCE(
            "temp".codigo = current_setting('app.clube.codigo', TRUE)::VARCHAR, 
            FALSE
          )
          AND NOT "temp".excluir
    )
  );

-- Permissão para definir usuários de um clube que está sendo criado
CREATE POLICY "O usuário que está criando o clube pode escrever em clube_x_usuario."
  ON clube_x_usuario FOR INSERT
  WITH CHECK (
    COALESCE(
      get_id_usuario() = current_setting('app.clube.proprietario', TRUE)::INT4, 
      FALSE
    )
    AND COALESCE(
      id_clube = current_setting('app.clube.id', TRUE)::INT4, 
      FALSE
    )
    -- Apenas o usuário que está criando o clube pode ser atribuído como proprietário.
    AND (id_permissao <> 0 OR id_usuario = get_id_usuario())
  );

CREATE POLICY "Apenas usuários autenticados podem atualizar em clube_x_usuario."
  ON clube_x_usuario AS RESTRICTIVE FOR UPDATE
  USING (autenticado());

-- Para os participantes com permissão de membro.
CREATE POLICY "O usuário vinculado ao registro pode atualizá-lo em clube_x_usuario, desde que a permissão inserida seja a de membro."
  ON clube_x_usuario FOR UPDATE
  USING (id_usuario = get_id_usuario())
  -- Membros não podem alterar sua permissão.
  WITH CHECK (clube_x_usuario.id_permissao = 2);

-- Para os participantes com permissão de administrador.
CREATE POLICY "O administrador pode atualizar em clube_x_usuario, desde que o registro esteja vinculado a ele ou a um membro."
  ON clube_x_usuario FOR UPDATE
  USING (COALESCE(get_permissao_clube(id_clube) = 1, FALSE))
  WITH CHECK (
    -- Administradores não podem definir o proprietário nem novos administradores.
    id_permissao <> 0 AND (id_usuario = get_id_usuario() OR id_permissao = 2)
  );

-- Para o proprietário do clube.
CREATE POLICY "O proprietário pode atualizar registros vinculados ao clube em clube_x_usuario."
  ON clube_x_usuario FOR UPDATE
  USING (COALESCE(get_permissao_clube(id_clube) = 0, FALSE)); 

---------------

ALTER TABLE atividades ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Apenas usuários autenticados podem ler em atividades."
  ON atividades AS RESTRICTIVE FOR SELECT
  USING (autenticado());

CREATE POLICY "O proprietário pode ler em atividades."
  ON atividades AS PERMISSIVE FOR SELECT
  USING (id_autor = get_id_usuario());

CREATE POLICY "Os participantes podem ler atividades dos seus clubes."
  ON atividades AS PERMISSIVE FOR SELECT
  USING (get_permissao_clube(id_clube) IS NOT NULL);

CREATE POLICY "Proprietário e administradores de clubes podem escrever em atividades."
  ON atividades FOR INSERT
  WITH CHECK (
    autenticado()
    -- O autor deve ser o usuário que está criando a atividade.
    AND id_autor = get_id_usuario()
    AND (
      -- O proprietário do clubes pode criar atividade.
      COALESCE(get_permissao_clube(id_clube) = 0, FALSE) 
      -- Os administradores do clube podem criar atividade.
      OR COALESCE(get_permissao_clube(id_clube) = 1, FALSE)
    )
  );

CREATE POLICY "O proprietário pode atualizar em atividades."
  ON atividades FOR UPDATE
  USING (autenticado() AND id_autor = get_id_usuario());

---------------

ALTER TABLE questao_x_atividade ENABLE ROW LEVEL SECURITY;

-- Retorna o ID do clube correspondente a _id_atividade.
-- Retorna NULL se nenhuma atividade correspondente for encontrada.
CREATE OR REPLACE FUNCTION get_clube_atividade(
  _id_atividade INT4, 
  _incluir_excluidos BOOLEAN DEFAULT FALSE
) RETURNS INT4 AS $$
  SELECT id_clube FROM atividades 
      WHERE atividades.id = _id_atividade 
          AND (COALESCE(_incluir_excluidos, FALSE) OR NOT excluir)
      LIMIT 1;
$$ LANGUAGE SQL;

-- Retorna o ID do autor da atividade correspondente a _id_atividade.
-- Retorna NULL se nenhuma atividade correspondente for encontrada.
CREATE OR REPLACE FUNCTION get_autor_atividade(
  _id_atividade INT4, 
  _incluir_excluidos BOOLEAN DEFAULT FALSE
) RETURNS INT4 AS $$
  SELECT id_autor FROM atividades 
      WHERE atividades.id = _id_atividade 
          AND (COALESCE(_incluir_excluidos, FALSE) OR NOT excluir)
      LIMIT 1;
$$ LANGUAGE SQL;

CREATE POLICY "Apenas usuários autenticados podem ler em questao_x_atividade."
  ON questao_x_atividade AS RESTRICTIVE FOR SELECT
  USING (autenticado());

CREATE POLICY "Os participantes podem ler registros dos seus clubes."
  ON questao_x_atividade AS PERMISSIVE FOR SELECT
  USING (
    get_permissao_clube(get_clube_atividade(id_atividade, TRUE)) IS NOT NULL
  );

CREATE POLICY "O autor da atividade pode escrever em questao_x_atividade."
  ON questao_x_atividade FOR INSERT
  WITH CHECK (
    autenticado()
    AND COALESCE(get_id_usuario() = get_autor_atividade(id_atividade), FALSE)
  );

CREATE POLICY "O autor da atividade pode atualizar em questao_x_atividade."
  ON questao_x_atividade FOR UPDATE
  USING (
    autenticado()
    AND COALESCE(get_id_usuario() = get_autor_atividade(id_atividade), FALSE)
  )
  WITH CHECK (
    -- Essa abordagem permite a atualização do ID da atividade, desde que o usuário seja altor de ambas.
    -- O ideal é substituir por um gatilho que não permita a atualização do ID da atividade.
    COALESCE(get_id_usuario() = get_autor_atividade(id_atividade), FALSE)
  );

---------------

ALTER TABLE resposta_x_questao_x_atividade ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Apenas usuários autenticados podem ler em resposta_x_questao_x_atividade."
  ON resposta_x_questao_x_atividade AS RESTRICTIVE FOR SELECT
  USING (autenticado());

CREATE POLICY "Proprietário e administradores podem ler registros dos seus clubes."
  ON resposta_x_questao_x_atividade AS PERMISSIVE FOR SELECT
  USING (
    -- O proprietário da resposta pode lê-la.
    id_usuario = get_id_usuario()
    -- Proprietário e administradores do clube vinculado à resposta pode lê-la.
    OR COALESCE (
      get_permissao_clube(
        get_clube_atividade(
          (
            SELECT x.id_atividade FROM questao_x_atividade AS x 
                WHERE x.id = resposta_x_questao_x_atividade.id_questao_x_atividade
                LIMIT 1
          ), 
          TRUE
        )
      ) IN (0, 1),
      FALSE
    )
  );

CREATE POLICY "Participantes do clube vinculado ao registro podem escrever em resposta_x_questao_x_atividade."
  ON resposta_x_questao_x_atividade FOR INSERT
  WITH CHECK (
    get_permissao_clube(
      get_clube_atividade(
        (SELECT x.id_atividade FROM questao_x_atividade AS x 
            WHERE x.id = resposta_x_questao_x_atividade.id_questao_x_atividade
            LIMIT 1)
      )
    ) IS NOT NULL
  );

CREATE POLICY "O autor da atividade pode atualizar em resposta_x_questao_x_atividade."
  ON resposta_x_questao_x_atividade FOR UPDATE
  USING (id_usuario = get_id_usuario())
  WITH CHECK (
    -- Essa abordagem permite a atualização de id_questao_x_atividade.
    -- O ideal é substituir por um gatilho que não permita esse comportamento.
    id_usuario = get_id_usuario()
  );

CREATE POLICY "Proprietário e administradores podem atualizar em resposta_x_questao_x_atividade."
  ON resposta_x_questao_x_atividade AS PERMISSIVE FOR UPDATE
  USING (
    -- Proprietário e administradores do clube vinculado à resposta pode atualizá-la.
    COALESCE (
      get_permissao_clube(
        get_clube_atividade(
          (
            SELECT x.id_atividade FROM questao_x_atividade AS x 
                WHERE x.id = resposta_x_questao_x_atividade.id_questao_x_atividade
                LIMIT 1
          ), 
          TRUE
        )
      ) IN (0, 1),
      FALSE
    )
  );

---------------

ALTER TABLE resposta_x_questao ENABLE ROW LEVEL SECURITY;

CREATE POLICY "O usuário autenticado pode ler em resposta_x_questao."
  ON resposta_x_questao AS PERMISSIVE FOR SELECT
  USING (autenticado());

CREATE POLICY "Apenas o proprietário pode ler em resposta_x_questao."
  ON resposta_x_questao AS RESTRICTIVE FOR SELECT
  USING (id_usuario = get_id_usuario());

CREATE POLICY "O usuário autenticado pode escrever em resposta_x_questao."
  ON resposta_x_questao FOR INSERT
  WITH CHECK (autenticado());

CREATE POLICY "O proprietário pode atualizar em resposta_x_questao."
  ON resposta_x_questao FOR UPDATE
  USING (id_usuario = get_id_usuario());

----------------------------------------------------------------------------------------------------------------------------

-- Função para truncar um timestamp em milissegundos.
CREATE OR REPLACE FUNCTION truncar_data_hora("timestamp" TIMESTAMP WITH TIME ZONE) 
RETURNS TIMESTAMP WITHOUT TIME ZONE 
LANGUAGE SQL 
AS $$
  SELECT date_trunc('milliseconds', "timestamp" AT TIME ZONE 'UTC');
$$;

----------------------------------------------------------------------------------------------------------------------------

-- Função para o valor timestamp (sem fuso horário) padrão usado nos registros.
CREATE OR REPLACE FUNCTION valor_data_hora_padrao() 
RETURNS TIMESTAMP WITHOUT TIME ZONE 
LANGUAGE SQL 
AS $$
  SELECT truncar_data_hora(now());
$$;

----------------------------------------------------------------------------------------------------------------------------

-- Função para gerenciar a data de modificação dos registros das tabelas. 
-- Será vinculada a um gatilho BEFORE INSERT OR UPDATE em cada tabela.
CREATE OR REPLACE FUNCTION atualizar_data_modificacao() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL 
AS $$
BEGIN
  IF ((TG_OP = 'UPDATE') AND (NEW IS NOT DISTINCT FROM OLD)) THEN
    RETURN NEW;
  END IF;
  IF ((NEW."data_modificacao" IS NULL) 
      OR ((TG_OP = 'UPDATE') AND (NEW."data_modificacao" = OLD."data_modificacao"))
  ) THEN
    NEW."data_modificacao" := valor_data_hora_padrao();
  ELSE 
    NEW."data_modificacao" := truncar_data_hora(NEW."data_modificacao" AT TIME ZONE 'UTC');
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_on_questoes_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "questoes"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_assuntos_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "assuntos"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_questao_x_assunto_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "questao_x_assunto"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_tipos_alternativa_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "tipos_alternativa"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_alternativas_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "alternativas"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_questoes_caderno_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "questoes_caderno"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_usuarios_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "usuarios"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_permissao_acesso_banco_questoes_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "permissao_acesso_banco_questoes"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_clubes_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "clubes"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_tipos_permissao_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "tipos_permissao"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_clube_x_usuario_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "clube_x_usuario"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_atividades_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "atividades"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_questao_x_atividade_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "questao_x_atividade"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

CREATE TRIGGER trigger_on_resposta_x_questao_x_atividade_before_insert_or_update
  BEFORE INSERT OR UPDATE ON "resposta_x_questao_x_atividade"
  FOR EACH ROW EXECUTE PROCEDURE atualizar_data_modificacao();

-- Função para o gatilho "trigger_on_resposta_x_questao_before_insert_update".
CREATE OR REPLACE FUNCTION antes_de_inserir_ou_atualizar_resposta_x_questao() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL 
AS $$
BEGIN
  IF ((TG_OP = 'UPDATE') AND (NEW IS NOT DISTINCT FROM OLD)) THEN
    -- Abortar silenciosamente a atualização.
    RETURN NULL;
  END IF;

  IF ((NEW.data_modificacao IS NULL) 
      OR ((TG_OP = 'UPDATE') AND (NEW.data_modificacao = OLD.data_modificacao))
  ) THEN
    NEW.data_modificacao := valor_data_hora_padrao();
  ELSE 
    -- Quando uma dada de modificação não salva é fornecida.
    NEW.data_modificacao := truncar_data_hora(NEW.data_modificacao AT TIME ZONE 'UTC');
  END IF;

  IF (NEW.resposta IS NULL) THEN
    NEW.excluir := TRUE;
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_on_resposta_x_questao_before_insert_or_update
  BEFORE INSERT OR UPDATE ON resposta_x_questao
  FOR EACH ROW EXECUTE PROCEDURE antes_de_inserir_ou_atualizar_resposta_x_questao();

----------------------------------------------------------------------------------------------------------------------------

-- Função para alimentar a tabela "log_banco_questoes". 
-- Será vinculada a um gatilho AFTER INSERT OR UPDATE OR DELETE nas tabelas "questoes", "assunto_x_assunto_pai", "questao_x_assunto", "alternativas" e "questoes_caderno".
CREATE OR REPLACE FUNCTION registra_log_banco_questoes() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL 
AS $$
DECLARE
  _pk_registro JSONB;
  _registro RECORD;
  _email CONSTANT VARCHAR := auth.email();
BEGIN
  IF TG_OP = 'DELETE' THEN
    _registro := OLD;
  ELSE
    IF ((TG_OP = 'UPDATE') AND (NEW IS NOT DISTINCT FROM OLD)) THEN
      RETURN NEW;
    END IF;
    _registro := NEW;
  END IF;

  IF TG_TABLE_NAME = 'questoes' THEN
    _pk_registro := json_build_object('id', _registro."id");
  ELSIF TG_TABLE_NAME = 'assunto_x_assunto_pai' THEN
    _pk_registro := json_build_object('id', _registro."id");
  ELSIF TG_TABLE_NAME = 'questao_x_assunto' THEN
    _pk_registro := json_build_object('id_questao', _registro."id_questao", 'id_assunto', _registro."id_assunto");
  ELSIF TG_TABLE_NAME = 'alternativas' THEN
    _pk_registro := json_build_object('id_questao', _registro."id_questao", 'sequencial', _registro."sequencial");
  ELSIF TG_TABLE_NAME = 'questoes_caderno' THEN
    _pk_registro := json_build_object('id', _registro."id");
  ELSE
    -- Se a trigger for acionada em outra tabela, retornar sem fazer nada
    RETURN NULL;
  END IF;

  INSERT INTO log_banco_questoes ("id_usuario", "nome", "email", "tabela", "pk_registro", "operacao", "data")
      VALUES ((SELECT "id" FROM "usuarios" WHERE "usuarios"."email" = _email LIMIT 1), CURRENT_USER, _email, TG_TABLE_NAME, _pk_registro, TG_OP, NOW());

  RETURN _registro;
END;
$$;


CREATE TRIGGER trigger_on_questoes_log_after_insert_or_update_or_delete 
  AFTER INSERT OR UPDATE OR DELETE ON questoes
  FOR EACH ROW EXECUTE FUNCTION registra_log_banco_questoes(); 

CREATE TRIGGER trigger_on_assunto_x_assunto_pai_log_after_insert_or_update_or_delete 
  AFTER INSERT OR UPDATE OR DELETE ON assunto_x_assunto_pai
  FOR EACH ROW EXECUTE FUNCTION registra_log_banco_questoes(); 

CREATE TRIGGER trigger_on_questao_x_assunto_log_after_insert_or_update_or_delete 
  AFTER INSERT OR UPDATE OR DELETE ON questao_x_assunto
  FOR EACH ROW EXECUTE FUNCTION registra_log_banco_questoes(); 

CREATE TRIGGER trigger_on_alternativas_log_after_insert_or_update_or_delete 
  AFTER INSERT OR UPDATE OR DELETE ON alternativas
  FOR EACH ROW EXECUTE FUNCTION registra_log_banco_questoes(); 

CREATE TRIGGER trigger_on_questoes_caderno_log_after_insert_or_update_or_delete 
  AFTER INSERT OR UPDATE OR DELETE ON questoes_caderno
  FOR EACH ROW EXECUTE FUNCTION registra_log_banco_questoes(); 


----------------------------------------------------------------------------------------------------------------------------

-- Função para o gatilho "trigger_on_auth_user_after_insert_or_update".
CREATE OR REPLACE FUNCTION tratar_perfil_usuario() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL 
-- A função ignora o RLS, pois será executada com o nível de permissão do usuário a criou.
SECURITY DEFINER
-- Forçar o esquema temporário a ser pesquisado por último e priorizar os objetos do esquesma nativo.
SET search_path = pg_catalog, public, pg_temp
AS $$
DECLARE var_id INT4;
BEGIN
  -- Se não existir um usuário correspondente, inserir.
  INSERT INTO usuarios ("id", "email", "nome", "foto", "soft_delete")
      VALUES (DEFAULT, NEW.email, NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url', FALSE)
  ON CONFLICT ("email")  
  -- Se já existir um usuário correspondente, atualizar.
  DO UPDATE SET ("email", "nome", "foto", "soft_delete") = (
    NEW.email, 
    COALESCE(NEW.raw_user_meta_data->>'nome', NEW.raw_user_meta_data->>'full_name'), 
    NEW.raw_user_meta_data->>'avatar_url', 
    FALSE
  )
  RETURNING "id" INTO var_id;
  IF (TG_OP = 'INSERT') THEN
    -- Incluir o ID do usuário nos metadados de aplicativo da tabela auth.users.
    UPDATE auth.users 
        SET "raw_app_meta_data" = "raw_app_meta_data" - 'id_usuario' || jsonb_build_object('id_usuario', var_id)
            WHERE email = NEW.email;
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_on_auth_user_after_insert_or_update
  AFTER INSERT OR UPDATE ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE tratar_perfil_usuario();

----------------------------------------------------------------------------------------------------------------------------

-- Função que retorna o ID do usuário atual em "usuarios".
-- Retorna -1 se o ID não for encontrado.
CREATE OR REPLACE FUNCTION get_id_usuario()
RETURNS INT4 AS $$
  SELECT COALESCE(
    (SELECT "id" FROM usuarios WHERE usuarios.email = auth.email() LIMIT 1), 
    -1
  );
$$ LANGUAGE SQL 
-- A função ignora o RLS, pois será executada com o nível de permissão do usuário a criou.
SECURITY DEFINER
-- Forçar o esquema temporário a ser pesquisado por último e priorizar os objetos do esquesma nativo.
SET search_path = pg_catalog, public, pg_temp;

----------------------------------------------------------------------------------------------------------------------------

-- Função que retorna `true` se o usuário atual estiver autenticado.
CREATE OR REPLACE FUNCTION autenticado()
RETURNS BOOL AS $$
  DECLARE var_resultado BOOL;
  BEGIN
    var_resultado := (auth.role() = 'authenticated');
    IF (var_resultado IS NULL) THEN
      RETURN FALSE;
    END IF;
    RETURN var_resultado;
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função que retorna `true` se o usuário atual for anônimo.
CREATE OR REPLACE FUNCTION anonimo()
RETURNS BOOL AS $$
  DECLARE var_resultado BOOL;
  BEGIN
    var_resultado := (auth.role() = 'anon');
    IF (var_resultado IS NULL) THEN
      RETURN FALSE;
    END IF;
    RETURN var_resultado;
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Visualização usada para remover dados de perfil que devem ser visualizados apenas pelo proprietário do reggistro.
CREATE OR REPLACE VIEW "view_usuarios" AS  
  SELECT * FROM usuarios WHERE usuarios.id = get_id_usuario()
  UNION 
  SELECT 
    id,
    NULL AS email,
    nome,
    NULL AS foto,
    soft_delete,
    data_modificacao
  FROM usuarios WHERE usuarios.id <> get_id_usuario();

----------------------------------------------------------------------------------------------------------------------------

-- Função que retorna o TRUE se o usuário correspondente a _id (o padrão é o ID do usuário atual) tiver permissão para inserir questões no banco de dados.
CREATE OR REPLACE FUNCTION get_permissao_inserir_questao(
  _id INT4 DEFAULT get_id_usuario()
) RETURNS BOOLEAN AS $$
  SELECT COALESCE(
    (SELECT "inserir" FROM permissao_acesso_banco_questoes WHERE permissao_acesso_banco_questoes.id_usuario = _id LIMIT 1), 
    FALSE
  );
$$ LANGUAGE SQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função que retorna o TRUE se o usuário correspondente a _id (o padrão é o ID do usuário atual) tiver permissão para editar questões no banco de dados.
CREATE OR REPLACE FUNCTION get_permissao_editar_questao(
  _id INT4 DEFAULT get_id_usuario()
) RETURNS BOOLEAN AS $$
  SELECT COALESCE(
    (SELECT "editar" FROM permissao_acesso_banco_questoes WHERE permissao_acesso_banco_questoes.id_usuario = _id LIMIT 1), 
    FALSE
  );
$$ LANGUAGE SQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função que retorna o TRUE se o usuário correspondente a _id (o padrão é o ID do usuário atual) tiver permissão para excluir questões no banco de dados.
CREATE OR REPLACE FUNCTION get_permissao_excluir_questao(
  _id INT4 DEFAULT get_id_usuario()
) RETURNS BOOLEAN AS $$
  SELECT COALESCE(
    (SELECT "excluir" FROM permissao_acesso_banco_questoes WHERE permissao_acesso_banco_questoes.id_usuario = _id LIMIT 1), 
    FALSE
  );
$$ LANGUAGE SQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função para inserir um assunto fornecendo o nome do seu assunto pai em vez do ID.
CREATE OR REPLACE FUNCTION inserir_assunto(
  assunto TEXT, --1
  assunto_pai TEXT DEFAULT NULL --2
) RETURNS SETOF "assunto_x_assunto_pai" AS $$
  DECLARE var_row_assunto_pai assunto_x_assunto_pai%ROWTYPE;
  BEGIN
    IF (assunto IS NULL) OR (assunto = '') THEN 
      RAISE EXCEPTION 'O assunto não pode ser NULL nem vazio.';
    END IF;

    IF assunto_pai = '' THEN 
      assunto_pai := NULL;
    END IF;

    IF assunto_pai IS NOT NULL THEN 
      SELECT * FROM "assunto_x_assunto_pai" INTO var_row_assunto_pai 
          WHERE LOWER("assunto_x_assunto_pai"."assunto") = LOWER(assunto_pai) FETCH FIRST 1 ROW ONLY;
      IF var_row_assunto_pai."id" IS NULL THEN
        RAISE EXCEPTION 'O assunto pai "%" ainda não foi inserido.', assunto_pai;
      END IF;
    END IF;

    RETURN QUERY INSERT INTO "assunto_x_assunto_pai" ("id", "assunto", "id_assunto_pai") 
        VALUES (DEFAULT, assunto, var_row_assunto_pai."id")
            RETURNING *;
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Visualização com os assuntos e suas respectivas hierarquias.
CREATE OR REPLACE VIEW "view_assuntos" AS
  WITH RECURSIVE "tb_temp_view_assuntos" AS
  (
    SELECT
      "assunto_x_assunto_pai"."id",
      "assunto_x_assunto_pai"."assunto",
      ARRAY ["assunto_x_assunto_pai"."id"] AS "hierarquia"
    FROM "assunto_x_assunto_pai" WHERE "assunto_x_assunto_pai"."id_assunto_pai" IS NULL
    UNION ALL 
      SELECT
        "assunto_x_assunto_pai"."id",
        "assunto_x_assunto_pai"."assunto",
        ("tb_temp_view_assuntos"."hierarquia" || "assunto_x_assunto_pai"."id") AS "hierarquia"
      FROM "assunto_x_assunto_pai"
      INNER JOIN "tb_temp_view_assuntos" ON "assunto_x_assunto_pai"."id_assunto_pai" = "tb_temp_view_assuntos"."id"
  )
  SELECT
    "tb_temp_view_assuntos"."id",
    "tb_temp_view_assuntos"."assunto",
    "tb_temp_view_assuntos"."hierarquia"[1: array_upper("tb_temp_view_assuntos"."hierarquia", 1)-1] AS "hierarquia"
  FROM "tb_temp_view_assuntos"
  ORDER BY "tb_temp_view_assuntos"."hierarquia";

----------------------------------------------------------------------------------------------------------------------------

-- Função para filtrar os assuntos por ano e nível das questões. 
CREATE OR REPLACE FUNCTION get_assuntos(
  anos INT4[] DEFAULT NULL, 
  niveis INT4[] DEFAULT NULL
) RETURNS SETOF "assuntos" AS $$
  BEGIN
    RETURN QUERY SELECT DISTINCT assuntos.* FROM assuntos 
    INNER JOIN (
      SELECT 
        w.id,
        w.hierarquia,
        z.id_questao,
        z.ano,
        z.nivel
      FROM assuntos AS w
      INNER JOIN (
        SELECT 
          x.id_assunto,
          x.id_questao,
          y.ano,
          y.nivel
        FROM questao_x_assunto AS x
        FULL OUTER JOIN questoes_caderno AS y ON y.id_questao = x.id_questao
        ORDER BY x.id_assunto
      ) AS z ON w.id = z.id_assunto
    ) AS juncao ON assuntos.id = juncao.id OR assuntos.id = ANY (juncao.hierarquia)
    WHERE 
      (
        (anos IS NULL) OR 
        (anos = '{}'::INT4[]) OR 
        (juncao.ano = ANY (anos))
      ) 
      AND 
      (
        (niveis IS NULL) OR 
        (niveis = '{}'::INT4[]) OR 
        (juncao.nivel = ANY (niveis))
      );
  END;
$$ LANGUAGE PLPGSQL; 

----------------------------------------------------------------------------------------------------------------------------

-- Função para o gatilho "trigger_on_assunto_x_assunto_pai_after_insert_or_update".
CREATE OR REPLACE FUNCTION alterar_tabela_assuntos() RETURNS TRIGGER AS $$
  DECLARE linha RECORD;
  BEGIN
    -- Aqui temos um bloco IF que confirmará o tipo de operação.
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
      FOR linha IN (
        SELECT "id", "assunto", "hierarquia" FROM "view_assuntos"
        EXCEPT
        SELECT "id", "assunto", "hierarquia" FROM "assuntos"
      ) LOOP
        -- Se não existir um elemento correspondente, inserir.
        INSERT INTO "assuntos" ("id", "assunto", "hierarquia") VALUES (linha."id", linha."assunto", linha."hierarquia")
        ON CONFLICT ("id") 
        -- Se já existir um elemento correspondente, atualizar.
        DO UPDATE SET ("assunto", "hierarquia") = (linha."assunto", linha."hierarquia") WHERE "assuntos"."id" = linha."id";
      END LOOP;
      -- Fazer um loop no que está em "assuntos" mas não está em "view_assuntos", excluindo esses registros.
      FOR linha IN (
        SELECT "id", "assunto", "hierarquia" FROM "assuntos"
        EXCEPT
        SELECT "id", "assunto", "hierarquia" FROM "view_assuntos"
      ) LOOP
        DELETE FROM "assuntos" WHERE ("id", "assunto", "hierarquia") = (linha."id", linha."assunto", linha."hierarquia");
      END LOOP;
      RETURN NEW;
    END IF;
    RETURN NULL;
  END;
$$ LANGUAGE PLPGSQL;

-- Gatilho executado após uma atualização ou inserção na tabela "assunto_x_assunto_pai". 
-- Esse gatilho mantém a tabela "assuntos" com os mesmos dados da visualização "view_assuntos". 
-- O evento AFTER DELETE não está incluso porque a restrição de chave estramgeira entre "assuntos"."id" e "assunto_x_assunto_pai"."id" está configurada com ON DELETE CASCADE.
CREATE TRIGGER "trigger_on_assunto_x_assunto_pai_after_insert_or_update" 
  AFTER INSERT OR UPDATE ON "assunto_x_assunto_pai"
  --REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
  FOR EACH STATEMENT
  EXECUTE FUNCTION alterar_tabela_assuntos();

----------------------------------------------------------------------------------------------------------------------------

-- Função para inserir uma questão que não referencia outra. Retorna o ID da questão inserida.
CREATE OR REPLACE FUNCTION inserir_questao(
  _enunciado TEXT[], 
  _gabarito INT4, 
  _imagens_enunciado JSONB[], 
  _assuntos INT4[], 
  _alternativas JSONB[], 
  _ano INT4, 
  _nivel INT4, 
  _indice INT4 
) RETURNS TEXT AS $$
  DECLARE _id_num INT4;
  DECLARE _id_alfa CONSTANT TEXT := CONCAT(_ano::TEXT, 'PF1N', _nivel::TEXT, 'Q', TRIM(to_char(_indice, '09')));
  BEGIN
    IF (
      (_enunciado IS NULL) OR 
      (_gabarito IS NULL) OR 
      (_assuntos IS NULL) OR 
      (_alternativas IS NULL) OR 
      (_ano IS NULL) OR 
      (_nivel IS NULL) OR 
      (_indice IS NULL)
    ) THEN 
      RAISE EXCEPTION 'Algum dos parâmetros obrigatórios é NULL.';
    END IF;
    IF (_enunciado = '{}') OR (_assuntos = '{}') OR (_alternativas = '{}') THEN 
      RAISE EXCEPTION '_enunciado, _assuntos ou _alternativas é vazio.';
    END IF;

    IF _imagens_enunciado = '{}' THEN 
      _imagens_enunciado := NULL;
    END IF;

    INSERT INTO questoes ("id", enunciado, gabarito, imagens_enunciado) 
        VALUES (DEFAULT, _enunciado, _gabarito, _imagens_enunciado)
            RETURNING questoes.id INTO _id_num;

    FOR i IN array_lower(_assuntos, 1)..array_upper(_assuntos, 1) LOOP
      INSERT INTO questao_x_assunto (id_questao, id_assunto) VALUES (_id_num, _assuntos[i]);
    END LOOP;

    FOR i IN array_lower(_alternativas, 1)..array_upper(_alternativas, 1) LOOP
      INSERT INTO alternativas (id_questao, sequencial, id_tipo, conteudo) 
          SELECT _id_num, sequencial, id_tipo, conteudo 
              FROM jsonb_populate_record(NULL::alternativas, _alternativas[i]);
    END LOOP;

    INSERT INTO questoes_caderno ("id", ano, nivel, indice, id_questao) 
        VALUES (_id_alfa, _ano, _nivel, _indice, _id_num);

    RETURN _id_alfa;
  END;
$$ LANGUAGE PLPGSQL;

-- Função para inserir uma questão que referencia outra. Retorna o ID da questão inserida.
CREATE OR REPLACE FUNCTION inserir_questao(
  _ano INT4, 
  _nivel INT4, 
  _indice INT4, 
  _id_referencia INT4 -- ID da questão que será referenciada.
) RETURNS TEXT AS $$
  DECLARE _id_alfa CONSTANT TEXT := CONCAT(_ano::TEXT, 'PF1N', _nivel::TEXT, 'Q', TRIM(to_char(_indice, '09')));
  BEGIN
    INSERT INTO "questoes_caderno" ("id", "ano", "nivel", "indice", "id_questao") 
        VALUES (_id_alfa, _ano, _nivel, _indice, _id_referencia);
    RETURN _id_alfa;
  END;
$$ LANGUAGE PLPGSQL RETURNS NULL ON NULL INPUT;

----------------------------------------------------------------------------------------------------------------------------

-- Visualização que consolida os dados das questões.
CREATE OR REPLACE VIEW view_questoes AS SELECT 
  questoes_caderno."id" AS id_questao_caderno, 
  questoes_caderno.id_questao AS "id",
  questoes_caderno.ano, 
  questoes_caderno.nivel, 
  questoes_caderno.indice, 
  questoes.enunciado, 
  questoes.gabarito, 
  questoes.imagens_enunciado, 
  ARRAY(
    -- Exibir o ID dos assuntos.
    SELECT id_assunto FROM questao_x_assunto WHERE id_questao = questoes_caderno.id_questao
    ----------
    -- Exibir o nome dos assuntos.
    --SELECT assunto FROM (
      --SELECT * FROM questao_x_assunto WHERE id_questao = questoes_caderno.id_questao
    --) AS tb_temp
    --INNER JOIN assunto_x_assunto_pai ON assunto_x_assunto_pai."id" = tb_temp.id_assunto
    ----------
  ) AS assuntos, 
  ARRAY(
    SELECT jsonb_build_object(
      'id_questao', id_questao, 
      'sequencial', sequencial, 
      'id_tipo', id_tipo, 
      'conteudo', conteudo
    ) FROM alternativas WHERE id_questao = questoes."id"
  ) AS alternativas
  FROM questoes_caderno
  INNER JOIN questoes ON questoes."id" = questoes_caderno.id_questao;

----------------------------------------------------------------------------------------------------------------------------

-- Visualização que consolida os dados das questões sem repetir as que foram aplicadas em mais de um caderno.
-- Das questões aplicadas em mais de um caderno, será exibida aquela mais antiga e cujo nível é o menor.
CREATE OR REPLACE VIEW view_questoes_distintas AS SELECT * FROM view_questoes WHERE id_questao_caderno IN (
  -- Selecionar os ID's (textuais) das questões distintas.
  WITH tb_temp AS (
    WITH tb_temp2 AS (SELECT id_questao, (10 * ano + nivel) AS comparador FROM questoes_caderno)
    SELECT id_questao, MIN(comparador) AS min_comparador FROM tb_temp2 GROUP BY id_questao
  )
  SELECT questoes_caderno."id" FROM tb_temp
  INNER JOIN questoes_caderno ON 
      tb_temp.id_questao = questoes_caderno.id_questao AND 
      tb_temp.min_comparador = (10 * questoes_caderno.ano + questoes_caderno.nivel)
);

----------------------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION get_num_questoes() RETURNS INT4 AS $$
  SELECT COUNT(*) FROM view_questoes;
$$ LANGUAGE SQL;

----------------------------------------------------------------------------------------------------------------------------

-- Visualização que consolida os dados dos clubes.
CREATE or replace VIEW "view_clubes" AS SELECT 
  "clubes"."id", 
  "clubes"."nome", 
  "clubes"."descricao", 
  "clubes"."data_criacao", 
  "clubes"."privado", 
  "clubes"."codigo",
  "clubes"."capa",
  ARRAY(
    SELECT jsonb_build_object(
      'id_usuario', clube_x_usuario.id_usuario, 
      'nome', (SELECT usuarios.nome FROM usuarios WHERE usuarios.id = clube_x_usuario.id_usuario),
      'id_clube', clube_x_usuario.id_clube, 
      'id_permissao', clube_x_usuario.id_permissao
    ) FROM clube_x_usuario WHERE clube_x_usuario.id_clube = clubes.id
  ) AS "usuarios"
  FROM "clubes"
  INNER JOIN "clube_x_usuario" 
      ON "clube_x_usuario"."id_clube" = "clubes"."id" AND "clube_x_usuario"."id_permissao" = 0
  WHERE "clubes"."excluir" = FALSE AND "clube_x_usuario"."excluir" = FALSE;

----------------------------------------------------------------------------------------------------------------------------

-- Função para inserir um clube. Retorna o clube inserido.
CREATE OR REPLACE FUNCTION inserir_clube(
  _nome TEXT, 
  _codigo TEXT, 
  _descricao TEXT DEFAULT NULL, 
  _privado BOOL DEFAULT FALSE, 
  _administradores INT4[] DEFAULT NULL, 
  _membros INT4[] DEFAULT NULL, 
  _capa TEXT DEFAULT NULL 
) RETURNS SETOF view_clubes AS $$
  DECLARE _clube clubes%ROWTYPE;
  BEGIN 
    IF (autenticado() = FALSE) THEN 
      RAISE EXCEPTION ' Usuário não autenticado.';
    END IF;
    IF (COALESCE(_nome, '') = '') THEN 
      RAISE EXCEPTION 'O nome do clube não pode ser NULL nem vazio.';
    END IF;
    IF (COALESCE(_codigo, '') = '') THEN 
      RAISE EXCEPTION 'O codigo do clube não pode ser NULL nem vazio.';
    END IF;
    IF (_privado IS NULL) THEN 
      RAISE EXCEPTION 'O parâmetro "privado" não pode ser NULL.';
    END IF;

    IF _descricao = '' THEN 
      _descricao := NULL;
    END IF;
    IF _capa = '' THEN 
      _capa := NULL;
    END IF;

    -- Afeta a política de leitura (quando RLS está habilitado) necessária para criar um registro em clubes.
    PERFORM set_config('app.clube.codigo'::TEXT, _codigo::TEXT, TRUE);

    INSERT INTO clubes ("id", nome, codigo, descricao, data_criacao, privado, capa, excluir) 
        VALUES (DEFAULT, _nome, _codigo, _descricao, DEFAULT, _privado, _capa, DEFAULT)
            RETURNING * INTO _clube;

    PERFORM set_config('app.clube.proprietario'::TEXT, get_id_usuario()::TEXT, TRUE);
    PERFORM set_config('app.clube.id'::TEXT, _clube."id"::TEXT, TRUE);

    INSERT INTO clube_x_usuario (id_clube, id_usuario, id_permissao, data_admissao, excluir) 
        VALUES (_clube."id", get_id_usuario(), 0, _clube.data_criacao, DEFAULT);

    IF NOT COALESCE(_administradores, '{}') = '{}' THEN
      FOR i IN array_lower(_administradores, 1)..array_upper(_administradores, 1) LOOP
        INSERT INTO clube_x_usuario (id_clube, id_usuario, id_permissao, data_admissao, excluir) 
            VALUES (_clube."id", _administradores[i], 1, _clube.data_criacao, DEFAULT);
      END LOOP;
    END IF;

    IF NOT COALESCE(_membros, '{}') = '{}' THEN
      FOR i IN array_lower(_membros, 1)..array_upper(_membros, 1) LOOP
        INSERT INTO clube_x_usuario (id_clube, id_usuario, id_permissao, data_admissao, excluir) 
            VALUES (_clube."id", _membros[i], 2, _clube.data_criacao, DEFAULT);
      END LOOP;
    END IF;

    RETURN QUERY SELECT * FROM view_clubes WHERE view_clubes."id" = _clube."id" LIMIT 1; 
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função para atualizar os dados de um clube. Retorna o clube atualizado.
-- A capa e descrição não serão atualizadas se forem string vazia.
-- Os demais não serão atualizados se forem null.
CREATE OR REPLACE FUNCTION atualizar_clube(
  "id" INT4,
  nome TEXT DEFAULT NULL,
  codigo TEXT DEFAULT NULL,
  descricao TEXT DEFAULT '',
  privado BOOL DEFAULT NULL,
  administradores INT4 [ ] DEFAULT NULL,
  membros INT4 [ ] DEFAULT NULL,
  capa TEXT DEFAULT ''
) RETURNS SETOF "view_clubes" AS $$
  DECLARE var_sql_prefixo CONSTANT TEXT := 'UPDATE "clubes" SET ';
  DECLARE var_sql TEXT := var_sql_prefixo;
  DECLARE linha RECORD;
  BEGIN
    IF ("id" IS NULL) THEN 
      RAISE EXCEPTION 'O ID do clube não pode ser NULL.';
    END IF;

    IF (EXISTS(SELECT 1 FROM "clubes" WHERE "clubes"."id" = $1 AND "excluir" = TRUE)) THEN 
      RAISE EXCEPTION 'Não é possível atualizar um clube que foi excluído.';
    END IF;

    IF (nome IS NOT NULL) THEN 
      IF (nome = '') THEN 
        RAISE EXCEPTION 'O nome do clube não pode ser vazio.';
      END IF;
      var_sql := var_sql || quote_ident('nome') || ' = ' || quote_literal(nome);
    END IF;
    
    IF (codigo IS NOT NULL) THEN 
      IF (codigo = '') THEN 
        RAISE EXCEPTION 'O código do clube não pode ser vazio.';
      END IF;
      IF (var_sql <> var_sql_prefixo) THEN 
        var_sql := var_sql || ', '; 
      END IF;
      var_sql := var_sql || quote_ident('codigo') || ' = ' || quote_literal(codigo);
    END IF;

    IF ((descricao IS NULL) OR (descricao <> '')) THEN 
      IF (var_sql <> var_sql_prefixo) THEN 
        var_sql := var_sql || ', '; 
      END IF;
      var_sql := var_sql || quote_ident('descricao') || ' = ' || quote_nullable(descricao);
    END IF;

    IF (privado IS NOT NULL) THEN 
      IF (var_sql <> var_sql_prefixo) THEN 
        var_sql := var_sql || ', '; 
      END IF;
      var_sql := var_sql || quote_ident('privado') || ' = ' || quote_literal(privado);
    END IF;

    IF ((capa IS NULL) OR (capa <> '')) THEN 
      IF (var_sql <> var_sql_prefixo) THEN 
        var_sql := var_sql || ', '; 
      END IF;
      var_sql := var_sql || quote_ident('capa') || ' = ' || quote_nullable(capa);
    END IF;

    IF (var_sql <> var_sql_prefixo) THEN 
      EXECUTE var_sql || ' WHERE ' || quote_ident('id') || ' = ' || quote_literal(id);
    END IF;

    -- NÃO FOI DEVIDAMENTE TESTADO.
    IF ((administradores IS NOT NULL) OR (membros IS NOT NULL)) THEN 
      FOR linha IN (
        -- Selecionar todos os novos usuários e os que tiveram a permissão modificada.
        (
          SELECT "unnest" AS "id_usuario", 1 AS "id_permissao" FROM UNNEST(administradores) 
          UNION 
          SELECT "unnest" AS "id_usuario", 2 AS "id_permissao" FROM UNNEST(membros) 
        ) EXCEPT (
          SELECT "id_usuario", "id_permissao" FROM "clube_x_usuario" WHERE "clube_x_usuario"."id_clube" = id 
        )
      ) LOOP
        -- Se não existir um elemento correspondente, inserir.
        INSERT INTO "clube_x_usuario" ("id_clube", "id_usuario", "id_permissao", "data_admissao", "excluir") 
            VALUES (id, linha."id_usuario", linha."id_permissao", DEFAULT, DEFAULT)
        ON CONFLICT ("id_clube", "id_usuario") 
        -- Se já existir um elemento correspondente, atualizar.
        DO UPDATE SET "id_permissao" = linha."id_permissao",  "excluir" = FALSE
            WHERE "clube_x_usuario"."id_clube" = id AND "clube_x_usuario"."id_usuario" = linha."id_usuario";
      END LOOP;

      FOR linha IN (
        -- Selecionar os usuários que foram excluídos do clube.
        (
          SELECT "id_usuario", "id_permissao" FROM "clube_x_usuario" 
              WHERE "clube_x_usuario"."id_clube" = id AND "clube_x_usuario"."id_permissao" <> 0
        ) EXCEPT (
          SELECT "unnest" AS "id_usuario", 1 AS "id_permissao" FROM UNNEST(administradores) 
          UNION 
          SELECT "unnest" AS "id_usuario", 2 AS "id_permissao" FROM UNNEST(membros) 
        )
      ) LOOP 
        UPDATE "clube_x_usuario" SET "excluir" = TRUE
            WHERE ("clube_x_usuario"."id_clube", "clube_x_usuario"."id_usuario") = (id, linha."id_usuario");
      END LOOP;
    END IF;

    RETURN QUERY SELECT * FROM "view_clubes" WHERE "view_clubes"."id" = $1 LIMIT 1;
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função para adicionar o usuário atual ao clube correspondente ao código fornecido.
CREATE OR REPLACE FUNCTION entrar_clube(
  _codigo_clube TEXT,
  _id_permissao INT4 DEFAULT 2
) RETURNS SETOF "view_clubes" AS $$
  DECLARE _linha_clube clubes%ROWTYPE;
  DECLARE _id_usuario CONSTANT INT4 := get_id_usuario();
  BEGIN
    IF (_id_usuario = -1) THEN 
      RAISE EXCEPTION 'Usuário não encontrado.';
    END IF;
    IF (_codigo_clube IS NULL) OR (_codigo_clube = '') THEN 
      RAISE EXCEPTION 'O código do clube não pode ser NULL nem vazio.';
    END IF;
    IF (_id_permissao IS NULL) THEN 
      RAISE EXCEPTION 'O ID da permissão para o usuário não pode ser NULL.';
    END IF;

    PERFORM set_config('app.clube.codigo'::TEXT, _codigo_clube::TEXT, TRUE);

    SELECT * INTO _linha_clube FROM clubes WHERE clubes.codigo = _codigo_clube AND NOT clubes.excluir LIMIT 1;
    IF (_linha_clube IS NULL) THEN 
      RAISE EXCEPTION 'Nenhum clube encontrado com o código de acesso "%".', _codigo_clube;
    END IF;
    IF (_linha_clube.privado) THEN 
      -------------------
      RAISE EXCEPTION 'O ingresso em clube privado ainda não está implementado.';
      -------------------
    ELSE
      -- Se não existir um elemento correspondente, inserir. 
      INSERT INTO clube_x_usuario (id_clube, id_usuario, id_permissao, data_admissao, excluir) 
          VALUES (_linha_clube."id", _id_usuario, _id_permissao, DEFAULT, DEFAULT)
      ON CONFLICT (id_clube, id_usuario) 
      -- Se já existir um elemento correspondente, atualizar.
      DO UPDATE SET excluir = FALSE 
          WHERE clube_x_usuario.id_clube = _linha_clube."id" AND clube_x_usuario.id_usuario = _id_usuario;
    END IF;

    RETURN QUERY SELECT * FROM view_clubes WHERE view_clubes."id" = _linha_clube."id" LIMIT 1;
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função para o gatilho "trigger_on_clubes_after_update".
CREATE OR REPLACE FUNCTION apos_atualizar_clubes() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL
AS $$
BEGIN
  IF (OLD."excluir" <> NEW."excluir") THEN
    BEGIN
      UPDATE "clube_x_usuario" SET "excluir" = NEW."excluir" 
          WHERE "id_clube" = NEW."id";
    END;
    UPDATE "atividades" SET "excluir" = NEW."excluir" 
        WHERE "id_clube" = NEW."id";
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_on_clubes_after_update
  AFTER UPDATE OF "excluir" ON "clubes"
  FOR EACH ROW EXECUTE PROCEDURE apos_atualizar_clubes();

----------------------------------------------------------------------------------------------------------------------------

-- Função para o gatilho "trigger_on_clube_x_usuario_after_update".
CREATE OR REPLACE FUNCTION apos_atualizar_clube_x_usuario() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL 
AS $$
DECLARE linha RECORD;
BEGIN
  IF (OLD."excluir" <> NEW."excluir") THEN
    FOR linha IN (
      SELECT "id" FROM "atividades" WHERE "atividades"."id_clube" = NEW."id_clube" AND "atividades"."excluir" = FALSE
    ) LOOP
      UPDATE "resposta_x_questao_x_atividade" SET "excluir" = NEW."excluir" 
          WHERE "resposta_x_questao_x_atividade"."excluir" <> NEW."excluir"
              AND
              -- Verificar vinculação da resposta ao usuário.
              "resposta_x_questao_x_atividade"."id_usuario" = NEW."id_usuario" 
              AND 
              -- Verificar vinculação da resposta ao clube usando a vinculação desta a uma atividade do clube.
              "resposta_x_questao_x_atividade"."id_questao_x_atividade" = ANY (
                SELECT "id" FROM "questao_x_atividade" WHERE "questao_x_atividade"."id_atividade" = linha."id"
              )
              -- Necessário para evitar que a exclusão de respostas antes da saída de um usuário do clube seja 
              -- desfeita se esse usuário reingressar no clune.
              AND (
                NEW."excluir" = TRUE 
                OR 
                -- "Garantir" que a última alteração de "OLD" e do corrente resposta ocorreram na mesma transação.
                OLD."data_modificacao" = "resposta_x_questao_x_atividade"."data_modificacao"
              );
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_on_clube_x_usuario_after_update
  AFTER UPDATE OF "excluir" ON "clube_x_usuario"
  FOR EACH ROW EXECUTE PROCEDURE apos_atualizar_clube_x_usuario();

----------------------------------------------------------------------------------------------------------------------------

-- Visualização que consolida os dados das atividades.
CREATE OR REPLACE VIEW "view_atividades" AS SELECT 
  "atividades"."id", 
  "atividades"."id_clube", 
  "atividades"."titulo", 
  "atividades"."descricao", 
  "atividades"."id_autor", 
  "atividades"."data_criacao", 
  "atividades"."data_liberacao", 
  "atividades"."data_encerramento",
  ARRAY(
    SELECT jsonb_build_object(
      'id', "questao_x_atividade"."id", 
      'id_questao_caderno', "id_questao_caderno"
    ) FROM "questao_x_atividade" 
        WHERE "id_atividade" = "atividades"."id" AND "questao_x_atividade"."excluir" = FALSE
  ) AS "questoes", 
  /* ARRAY(
    SELECT jsonb_build_object(
      'id_questao_x_atividade', "id_questao_x_atividade", 
      'id_usuario', "id_usuario", 
      'resposta', "resposta"
    ) FROM get_respostas_x_questoes_x_atividade("atividades"."id")
  ) AS "respostas" */
  '{}'::jsonb[] AS "respostas" -- As respostas serão buscadas separadamente.
  FROM "atividades"
  WHERE "atividades"."excluir" = FALSE;
  
----------------------------------------------------------------------------------------------------------------------------

-- Função para inserir uma atividade. [data_liberacao] e [data_encerramento] correspondem ao número de segundos desde 1970-01-01 00:00:00 UTC (negativo para carimbos de data/hora anteriores). 
-- Retorna a atividade inserida.
CREATE OR REPLACE FUNCTION inserir_atividade(
  id_clube INT4, 
  id_autor INT4, 
  titulo TEXT, 
  descricao TEXT DEFAULT NULL, 
  questoes TEXT[] DEFAULT NULL, 
  data_liberacao DOUBLE PRECISION DEFAULT NULL, -- Número de segundos após a época línux (no fusorário UTC)
  data_encerramento DOUBLE PRECISION DEFAULT NULL -- Número de segundos após a época línux (no fusorário UTC)
) RETURNS SETOF "view_atividades" AS $$
  DECLARE var_id_atividade INT4;
  DECLARE var_data_liberacao TIMESTAMP WITHOUT TIME ZONE; 
  DECLARE var_data_encerramento TIMESTAMP WITHOUT TIME ZONE;
  BEGIN
    IF (id_clube IS NULL) THEN 
      RAISE EXCEPTION 'O ID do clube não pode ser NULL.';
    END IF;
    IF (id_autor IS NULL) THEN 
      RAISE EXCEPTION 'O ID do autor data atividade não pode ser NULL.';
    END IF;
    IF (titulo IS NULL) OR (titulo = '') THEN 
      RAISE EXCEPTION 'O titulo da atividade não pode ser NULL nem vazio.';
    END IF;

    IF (descricao IS NOT NULL) AND (descricao = '') THEN 
      descricao := NULL;
    END IF;

    IF (data_liberacao IS NOT NULL) THEN
      var_data_liberacao := to_timestamp(data_liberacao) AT TIME ZONE 'UTC';
    END IF;

    IF (data_encerramento IS NOT NULL) THEN
      var_data_encerramento := to_timestamp(data_encerramento) AT TIME ZONE 'UTC';
    END IF;

    INSERT INTO "atividades" (
      "id", "id_clube", "id_autor", "titulo", "descricao", "data_criacao", "data_liberacao", "data_encerramento", "excluir"
    ) VALUES (
      DEFAULT, id_clube, id_autor, titulo, descricao, DEFAULT, var_data_liberacao, var_data_encerramento, DEFAULT
    ) RETURNING "id" INTO var_id_atividade;

    IF NOT ((questoes IS NULL) OR questoes = '{}') THEN
      FOR i IN array_lower(questoes, 1)..array_upper(questoes, 1) LOOP
        INSERT INTO "questao_x_atividade" ("id", "id_questao_caderno", "id_atividade", "excluir") 
            VALUES (DEFAULT, questoes[i], var_id_atividade, DEFAULT);
      END LOOP;
    END IF;

    RETURN QUERY SELECT * FROM "view_atividades" WHERE "view_atividades"."id" = var_id_atividade;
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função para atualizar os dados de uma atividade. Retorna a atividade atualizada.
-- A descrição não será atualizada se for uma string vazia.
-- A data de encerramento não será atualizada se for 0.0 (zero).
-- Os demais não serão atualizados se forem null.
CREATE OR REPLACE FUNCTION atualizar_atividade(
  _id INT4, 
  _titulo TEXT DEFAULT NULL, 
  _descricao TEXT DEFAULT '', 
  _questoes TEXT[] DEFAULT NULL, 
  _data_liberacao DOUBLE PRECISION DEFAULT NULL, -- Número de segundos após a época línux (no fusorário UTC)
  _data_encerramento DOUBLE PRECISION DEFAULT 0.0 -- Número de segundos após a época línux (no fusorário UTC)
) RETURNS SETOF view_atividades AS $$
  DECLARE _sql_prefixo CONSTANT TEXT := 'UPDATE ' || quote_ident('atividades') || ' SET ';
  DECLARE _sql TEXT := _sql_prefixo;
  DECLARE _linha RECORD;
  BEGIN
    IF (_id IS NULL) THEN 
      RAISE EXCEPTION 'O ID da atividade não pode ser NULL.';
    END IF;

    IF (
      EXISTS(SELECT 1 FROM atividades WHERE atividades."id" = _id AND atividades.excluir = TRUE)
    ) THEN 
      RAISE EXCEPTION 'Não é possível atualizar uma atividade que foi excluída.';
    END IF;

    IF (_titulo IS NOT NULL) THEN 
      IF (_titulo = '') THEN 
        RAISE EXCEPTION 'O titulo da atividade não pode ser vazio.';
      END IF;
      _sql := _sql || quote_ident('titulo') || ' = ' || quote_literal(_titulo);
    END IF;

    IF ((_descricao IS NULL) OR (_descricao <> '')) THEN 
      IF (_sql <> _sql_prefixo) THEN 
        _sql := _sql || ', '; 
      END IF;
      _sql := _sql || quote_ident('descricao') || ' = ' || quote_nullable(_descricao);
    END IF;

    IF (_data_liberacao IS NOT NULL) THEN 
      IF (_sql <> _sql_prefixo) THEN 
        _sql := _sql || ', '; 
      END IF;
      _sql := _sql || quote_ident('data_liberacao') || ' = ' || 
          quote_literal(to_timestamp(_data_liberacao) AT TIME ZONE 'UTC');
    END IF;

    IF ((_data_encerramento IS NULL) OR (_data_encerramento <> 0.0)) THEN 
      IF (_sql <> _sql_prefixo) THEN 
        _sql := _sql || ', '; 
      END IF;
      _sql := _sql || quote_ident('data_encerramento') || ' = ' || 
          quote_nullable(to_timestamp(_data_encerramento) AT TIME ZONE 'UTC');
    END IF;

    -- Atualizar os dados na tabela "atividades".
    IF (_sql <> _sql_prefixo) THEN 
      EXECUTE _sql || ' WHERE ' || quote_ident('id') || ' = ' || quote_literal(_id);
    END IF;

    -- Atualuzar a lista de questoes da atividade.
    IF ((_questoes IS NULL) OR (_questoes = '{}')) THEN 
      UPDATE questao_x_atividade SET excluir = TRUE 
          WHERE questao_x_atividade.id_atividade = _id;
    ELSE 
      -- Excluir as questoes removidas da atividade.
      UPDATE questao_x_atividade SET excluir = TRUE 
          WHERE questao_x_atividade.id_atividade = _id 
              AND NOT (questao_x_atividade.id_questao_caderno = ANY (_questoes));

      FOR _linha IN (
        -- Selecionar todas as novas questoes (incluindo as que estão sendo reinseridas na atividade).
        SELECT "unnest" AS id_questao_caderno, FALSE AS excluir FROM UNNEST(_questoes) 
        EXCEPT 
        SELECT id_questao_caderno, excluir FROM questao_x_atividade 
            WHERE questao_x_atividade.id_atividade = _id 
      ) LOOP
        -- Se não existir um elemento correspondente, inserir. 
        INSERT INTO questao_x_atividade ("id", id_questao_caderno, id_atividade, excluir) 
            VALUES (DEFAULT, _linha.id_questao_caderno, _id, DEFAULT)
        ON CONFLICT (id_atividade, id_questao_caderno)
        -- Se já existir um elemento correspondente, atualizar.
        DO UPDATE SET excluir = FALSE 
            WHERE questao_x_atividade.id_atividade = _id 
                AND questao_x_atividade.id_questao_caderno = _linha.id_questao_caderno;
      END LOOP;
    END IF;

    RETURN QUERY SELECT * FROM view_atividades WHERE view_atividades."id" = _id;
  END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------

-- Função para o gatilho "trigger_on_atividades_after_update".
CREATE OR REPLACE FUNCTION apos_atualizar_atividades() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL 
AS $$
BEGIN
  IF (OLD."excluir" <> NEW."excluir") THEN
    UPDATE "questao_x_atividade" SET "excluir" = NEW."excluir" 
        WHERE "id_atividade" = NEW."id";
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_on_atividades_after_update
  AFTER UPDATE OF "excluir" ON "atividades"
  FOR EACH ROW EXECUTE PROCEDURE apos_atualizar_atividades();

----------------------------------------------------------------------------------------------------------------------------

-- Função para o gatilho "trigger_on_questao_x_atividade_after_update".
CREATE OR REPLACE FUNCTION apos_atualizar_questao_x_atividade() 
RETURNS TRIGGER 
LANGUAGE PLPGSQL 
AS $$
BEGIN
  IF (OLD."excluir" <> NEW."excluir") THEN
    UPDATE "resposta_x_questao_x_atividade" SET "excluir" = NEW."excluir" 
        WHERE "id_questao_x_atividade" = NEW."id" 
            AND "excluir" <> NEW."excluir"
            -- Necessário para evitar que as exclusões de respostas ocorridas antes da exclusão de uma questão da atividade 
            -- seja desfeita se essa questão for inserida na atividade.
            AND (
              NEW."excluir" = TRUE 
              OR 
              -- "Garantir" que a última alteração de "OLD" e da corrente resposta ocorreram na mesma transação.
              OLD."data_modificacao" = "resposta_x_questao_x_atividade"."data_modificacao"
            );
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_on_questao_x_atividade_after_update
  AFTER UPDATE OF "excluir" ON "questao_x_atividade"
  FOR EACH ROW EXECUTE PROCEDURE apos_atualizar_questao_x_atividade();

----------------------------------------------------------------------------------------------------------------------------

-- Função para retornar as repostas dos usuários a uma atividade.
-- Se [id_usuario] for NULL, será retornado as respostas de todos os usuários.
CREATE OR REPLACE FUNCTION get_respostas_x_questoes_x_atividade(
  id_atividade INT4, 
  id_usuario INT4 DEFAULT NULL
) RETURNS SETOF "resposta_x_questao_x_atividade" AS $$
  BEGIN
    IF (id_atividade IS NULL) THEN 
      RAISE EXCEPTION 'O ID da atividade não pode ser NULL.';
    END IF;

    IF (id_usuario IS NULL) THEN 
      RETURN QUERY SELECT * FROM "resposta_x_questao_x_atividade" 
          WHERE "excluir" = FALSE 
              AND "id_questao_x_atividade" = ANY (
                  SELECT "id" FROM "questao_x_atividade" WHERE "questao_x_atividade"."id_atividade" = $1);
    ELSE 
      RETURN QUERY SELECT * FROM "resposta_x_questao_x_atividade" 
          WHERE "excluir" = FALSE 
              AND  "id_questao_x_atividade" = ANY (
                  SELECT "id" FROM "questao_x_atividade" WHERE "questao_x_atividade"."id_atividade" = $1)
              AND "resposta_x_questao_x_atividade"."id_usuario" = $2;
    END IF;
  END;
$$ LANGUAGE PLPGSQL;





/*
-- Funções extraídas do Supabase.
CREATE OR REPLACE FUNCTION auth.jwt()
RETURNS jsonb
LANGUAGE sql
STABLE
AS $function$
  select coalesce(
    nullif(current_setting('request.jwt.claim', true), ''),
    nullif(current_setting('request.jwt.claims', true), '')
  )::jsonb
$function$
----------------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION auth.role()
RETURNS text
LANGUAGE sql
STABLE
AS $function$
  select coalesce(
		nullif(current_setting('request.jwt.claim.role', true), ''),
		(nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
	)::text
  -- Pode ser simplificada por:
  -- select (auth.jwt() ->> 'role')::text
$function$
----------------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION auth.email()
RETURNS text
LANGUAGE sql
STABLE
AS $function$
  select coalesce(
		nullif(current_setting('request.jwt.claim.email', true), ''),
		(nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
	)::text
  -- Pode ser simplificada por:
  -- select (auth.jwt() ->> 'email')::text
$function$
*/


/*
BEGIN;
  DROP VIEW IF EXISTS "view_assuntos" CASCADE;
  DROP VIEW IF EXISTS "view_questoes" CASCADE;
  DROP VIEW IF EXISTS "view_questoes_distintas" CASCADE;

  DROP TRIGGER IF EXISTS "trigger_on_assunto_x_assunto_pai_after_insert_or_update" ON "assunto_x_assunto_pai" CASCADE;
  DROP FUNCTION IF EXISTS inserir_assunto CASCADE;
  DROP FUNCTION IF EXISTS alterar_tabela_assuntos CASCADE;
  DROP FUNCTION IF EXISTS inserir_questao(integer,integer,integer,integer) CASCADE;
  DROP FUNCTION IF EXISTS inserir_questao(text[],integer,text[],integer[],jsonb[],integer,integer,integer) CASCADE;
  DROP FUNCTION IF EXISTS inserir_clube CASCADE;
  DROP FUNCTION IF EXISTS inserir_atividade CASCADE;

  DROP TABLE IF EXISTS "resposta_x_questao" CASCADE;
  DROP TABLE IF EXISTS "resposta_x_questao_x_atividade" CASCADE;
  DROP TABLE IF EXISTS "questao_x_atividade" CASCADE;
  DROP TABLE IF EXISTS "atividades" CASCADE;
  DROP TABLE IF EXISTS "clube_x_usuario" CASCADE;
  DROP TABLE IF EXISTS "clubes" CASCADE;
  DROP TABLE IF EXISTS "usuarios" CASCADE;
  DROP TABLE IF EXISTS "tipos_permissao" CASCADE;
  DROP TABLE IF EXISTS "alternativas" CASCADE;
  DROP TABLE IF EXISTS "tipos_alternativa" CASCADE;
  DROP TABLE IF EXISTS "questao_x_assunto" CASCADE;
  DROP TABLE IF EXISTS "assuntos" CASCADE;
  DROP TABLE IF EXISTS "assunto_x_assunto_pai" CASCADE;
  DROP TABLE IF EXISTS "questoes_caderno" CASCADE;
  DROP TABLE IF EXISTS "questoes" CASCADE;
END;

/*
INSERT INTO "assunto_x_assunto_pai" ("id", "assunto", "id_assunto_pai") VALUES 
(1, 'Frações', NULL), 
(2, 'Lógica', NULL), 
(3, 'Matemática financeira', NULL), 
(4, 'Porcentagem', 3), 
(5, 'Álgebra', NULL), 
(6, 'Equações algébricas', 5), 
(7, 'Geometria', NULL), 
(8, 'Área', 7), 
(9, 'Área de polígonos', 8), 
(10, 'Área do quadrado', 9), 
(11, 'Área do triângulo', 9), 
(12, 'Isometria', 7), 
(13, 'Simetria', 12);


SELECT inserir_questao(
  ARRAY['Questão 1'], 0, NULL, ARRAY[1], 
  ARRAY[
    jsonb_build_object('sequencial', 0, 'id_tipo', 0, 'conteudo', 'Alternativa A'), 
    jsonb_build_object('sequencial', 1, 'id_tipo', 0, 'conteudo', 'Alternativa B'), 
    jsonb_build_object('sequencial', 2, 'id_tipo', 0, 'conteudo', 'Alternativa C'), 
    jsonb_build_object('sequencial', 3, 'id_tipo', 0, 'conteudo', 'Alternativa D'), 
    jsonb_build_object('sequencial', 4, 'id_tipo', 0, 'conteudo', 'Alternativa E') 
  ], 
  2019, 1, 1
);

SELECT inserir_questao(
  ARRAY['Questão 2'], 1, NULL, ARRAY[2, 3], 
  ARRAY[
    jsonb_build_object('sequencial', 0, 'id_tipo', 0, 'conteudo', 'Alternativa A'), 
    jsonb_build_object('sequencial', 1, 'id_tipo', 0, 'conteudo', 'Alternativa B'), 
    jsonb_build_object('sequencial', 2, 'id_tipo', 0, 'conteudo', 'Alternativa C'), 
    jsonb_build_object('sequencial', 3, 'id_tipo', 0, 'conteudo', 'Alternativa D'), 
    jsonb_build_object('sequencial', 4, 'id_tipo', 0, 'conteudo', 'Alternativa E') 
  ], 
  2019, 1, 2
);

SELECT inserir_questao(
  ARRAY['Questão 3'], 2, NULL, ARRAY[3, 4, 5], 
  ARRAY[
    jsonb_build_object('sequencial', 0, 'id_tipo', 0, 'conteudo', 'Alternativa A'), 
    jsonb_build_object('sequencial', 1, 'id_tipo', 0, 'conteudo', 'Alternativa B'), 
    jsonb_build_object('sequencial', 2, 'id_tipo', 0, 'conteudo', 'Alternativa C'), 
    jsonb_build_object('sequencial', 3, 'id_tipo', 0, 'conteudo', 'Alternativa D'), 
    jsonb_build_object('sequencial', 4, 'id_tipo', 0, 'conteudo', 'Alternativa E') 
  ], 
  2019, 1, 3
);

SELECT inserir_questao(
  ARRAY['Questão 4'], 3, NULL, ARRAY[4, 8], 
  ARRAY[
    jsonb_build_object('sequencial', 0, 'id_tipo', 0, 'conteudo', 'Alternativa A'), 
    jsonb_build_object('sequencial', 1, 'id_tipo', 0, 'conteudo', 'Alternativa B'), 
    jsonb_build_object('sequencial', 2, 'id_tipo', 0, 'conteudo', 'Alternativa C'), 
    jsonb_build_object('sequencial', 3, 'id_tipo', 0, 'conteudo', 'Alternativa D'), 
    jsonb_build_object('sequencial', 4, 'id_tipo', 0, 'conteudo', 'Alternativa E') 
  ], 
  2019, 2, 1
);

SELECT inserir_questao(
  ARRAY['Questão 5'], 4, ARRAY['imagem1', 'imagem2'], ARRAY[1], 
  ARRAY[
    jsonb_build_object('sequencial', 0, 'id_tipo', 0, 'conteudo', 'Alternativa A'), 
    jsonb_build_object('sequencial', 1, 'id_tipo', 0, 'conteudo', 'Alternativa B'), 
    jsonb_build_object('sequencial', 2, 'id_tipo', 0, 'conteudo', 'Alternativa C'), 
    jsonb_build_object('sequencial', 3, 'id_tipo', 0, 'conteudo', 'Alternativa D'), 
    jsonb_build_object('sequencial', 4, 'id_tipo', 0, 'conteudo', 'Alternativa E') 
  ], 
  2019, 3, 1
);

SELECT inserir_questao(2019, 3, 2, 4);
SELECT inserir_questao(2020, 1, 2, 4);

INSERT INTO "usuarios" ("id", "email") VALUES 
    (1, 'usuario1@gmail.com'), 
    (2, 'usuario2@gmail.com'), 
    (3, 'usuario3@gmail.com'), 
    (4, 'usuario4@gmail.com'), 
    (5, 'usuario5@gmail.com');

SELECT inserir_clube('Clube 1', 1);
SELECT inserir_clube('Clube 2', 2, TRUE, membros => ARRAY[3, 4]);
SELECT inserir_clube('Clube 3', 3, FALSE, ARRAY[4, 5],'{}');
SELECT inserir_clube('Clube 4', 4, FALSE, '{}','{}');
SELECT inserir_clube('Clube 5', 1, FALSE, '{2}','{3, 4, 5}');

SELECT inserir_tarefa(
  id_clube => 1, 
  id_autor => 1, 
  nome => 'Tarefa 1. Clube 1. Usuário 1.', 
  descricao => 'Descrição. Tarefa 1. Clube 1. Usuário 1.', 
  questoes => '{2019PF1N1Q01, 2019PF1N1Q02, 2019PF1N1Q03}', 
  publicar => TRUE, 
  data_final => '2023-10-19 10:23:54+00'
);
SELECT inserir_tarefa(
  id_clube => 1, 
  id_autor => 1, 
  nome => 'Tarefa 2. Clube 1. Usuário 1.', 
  descricao => 'Descrição. Tarefa 2. Clube 1. Usuário 1.', 
  questoes => '{2019PF1N1Q01, 2019PF1N1Q02}', 
  publicar => FALSE
);
SELECT inserir_tarefa(
  id_clube => 1, 
  id_autor => 1, 
  nome => 'Tarefa 3. Clube 1. Usuário 1.', 
  descricao => 'Descrição. Tarefa 3. Clube 1. Usuário 1.', 
  questoes => '{}'
);
SELECT inserir_tarefa(
  id_clube => 1, 
  id_autor => 1, 
  nome => 'Tarefa 4. Clube 1. Usuário 1.'
);
*/